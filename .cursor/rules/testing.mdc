---
alwaysApply: true
---

# Testing Rules

Comprehensive testing strategy for React/Next.js applications following FSD architecture principles.

## Testing Philosophy & Principles

### Testing Pyramid Strategy
- **Unit Tests (70%)**: Test individual components, functions, and utilities in isolation
- **Integration Tests (20%)**: Test component interactions and data flow
- **E2E Tests (10%)**: Test complete user journeys and critical business flows

### Testing Library Philosophy
- **Test from User's Perspective**: Test what users see and do, not implementation details
- **Accessibility-First Testing**: Ensure components work for all users, including those using assistive technologies
- **Behavior-Driven Testing**: Focus on component behavior rather than internal implementation
- **Confidence in Refactoring**: Tests should give confidence to refactor without breaking functionality

## Testing Framework Setup

### Core Testing Tools
- **Jest**: JavaScript testing framework for unit and integration tests
- **React Testing Library**: Simple and complete testing utilities for React components
- **Playwright**: End-to-end testing for complete user journeys
- **MSW (Mock Service Worker)**: API mocking for integration tests
- **Testing Library User Event**: Simulate user interactions

## FSD Testing Strategy

### Layer-Specific Testing Approaches

#### App Layer Testing
- **Route Testing**: Test routing and navigation
- **Layout Testing**: Test global layouts and providers
- **Metadata Testing**: Test SEO and page metadata
- **Error Boundary Testing**: Test global error handling

#### Pages Layer Testing
- **Page Component Testing**: Test complete page functionality
- **Page Integration Testing**: Test page with real data and user interactions
- **Page Accessibility Testing**: Ensure pages are accessible
- **Page Performance Testing**: Test page load times and performance

#### Widgets Layer Testing
- **Widget Integration Testing**: Test widget functionality with real data
- **Widget Interaction Testing**: Test user interactions within widgets
- **Widget State Testing**: Test widget state management
- **Widget Error Handling**: Test widget error states

#### Features Layer Testing
- **Feature Logic Testing**: Test business logic and feature functionality
- **Feature Integration Testing**: Test feature with external dependencies
- **Feature State Testing**: Test feature state management
- **Feature API Testing**: Test feature API interactions

#### Entities Layer Testing
- **Entity Model Testing**: Test data models and business logic
- **Entity API Testing**: Test API interactions and data transformation
- **Entity Validation Testing**: Test data validation and error handling
- **Entity State Testing**: Test entity state management

#### Shared Layer Testing
- **Utility Testing**: Test shared utilities and helpers
- **Component Testing**: Test shared UI components
- **Hook Testing**: Test shared custom hooks
- **API Testing**: Test shared API utilities

## Component Testing Guidelines

### Testing Best Practices
- **Test Behavior, Not Implementation**: Focus on what the component does, not how it does it
- **Use Semantic Queries**: Prefer `getByRole`, `getByLabelText`, `getByText` over `getByTestId`
- **Test Accessibility**: Ensure components are accessible to all users
- **Test Error States**: Test component behavior when things go wrong
- **Test Loading States**: Test component behavior during async operations

## Testing Best Practices

### Test Organization
- **Group Related Tests**: Use `describe` blocks to group related tests
- **Clear Test Names**: Use descriptive test names that explain what is being tested
- **One Assertion Per Test**: Each test should verify one specific behavior
- **Arrange-Act-Assert**: Structure tests with clear setup, execution, and verification

### Test Data Management
- **Use Factories**: Create test data using factory functions
- **Avoid Hardcoded Data**: Use dynamic test data generation
- **Clean Up After Tests**: Ensure tests don't affect each other
- **Mock External Dependencies**: Mock APIs, timers, and external services

### Test Maintenance
- **Keep Tests Simple**: Avoid complex test logic
- **Update Tests with Code**: Update tests when changing functionality
- **Remove Obsolete Tests**: Delete tests for removed functionality
- **Regular Test Reviews**: Review and refactor tests regularly

### Coverage and Quality
- **Meaningful Coverage**: Aim for meaningful test coverage, not just high numbers
- **Test Edge Cases**: Test boundary conditions and error scenarios
- **Test User Scenarios**: Focus on testing real user scenarios
- **Continuous Integration**: Run tests on every commit and PR

## Testing Anti-Patterns to Avoid

### Common Testing Mistakes
- **Testing Implementation Details**: Don't test internal component state or methods
- **Over-Mocking**: Don't mock everything; test real integrations when possible
- **Brittle Tests**: Avoid tests that break when implementation changes
- **Slow Tests**: Don't write tests that are unnecessarily slow
- **Testing Third-Party Code**: Don't test library functionality

### What Not to Test
- **Third-party libraries**: Don't test React, Next.js, or other library functionality
- **Generated code**: Don't test auto-generated code
- **Simple getters/setters**: Don't test simple property accessors
- **Configuration files**: Don't test static configuration

## Testing Documentation

### Test Documentation
- **Test README**: Document testing strategy and setup
- **Test Examples**: Provide examples of common testing patterns
- **Testing Guidelines**: Document team testing standards
- **Test Reviews**: Regular reviews of test quality and coverage

### Testing Metrics
- **Coverage Reports**: Track test coverage metrics
- **Test Performance**: Monitor test execution time
- **Test Reliability**: Track flaky tests and failures
- **Test Maintenance**: Monitor test maintenance overhead

Remember: Good tests are a safety net that enables confident refactoring and feature development. Focus on testing behavior that matters to users and business requirements.